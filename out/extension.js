"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.activate = activate;
const vscode = __importStar(require("vscode"));
const path = __importStar(require("path"));
const github_1 = require("./github");
const getRunList_1 = require("./github/getRunList");
const printToOutput_1 = require("./output/printToOutput");
const getFailedLogs_1 = require("./log/getFailedLogs");
const analyze_1 = require("./llm/analyze");
const secondPass_1 = require("./llm/secondPass");
const llmCache_1 = require("./llm/cache/llmCache");
const pinpointCache_1 = require("./llm/cache/pinpointCache");
function activate(context) {
    // Ï∫êÏãú Ï¥àÍ∏∞Ìôî (Ìïú Î≤àÎßå)
    try {
        llmCache_1.llmCache.init(context);
        pinpointCache_1.pinpointCache.init(context);
        console.log("[MAD Ops] LLM Ï∫êÏãú Ï¥àÍ∏∞Ìôî ÏôÑÎ£å");
    }
    catch (e) {
        console.error("‚ö†Ô∏è Ï∫êÏãú Ï¥àÍ∏∞Ìôî Ïã§Ìå®:", e);
    }
    const functionRegister = (functionHandler) => {
        const cmd = vscode.commands.registerCommand(`extension.${functionHandler.name}`, functionHandler);
        context.subscriptions.push(cmd);
    };
    const setOpenAiKey = async () => {
        const key = await vscode.window.showInputBox({
            prompt: "Enter your OpenAI API key",
            ignoreFocusOut: true,
            password: true,
        });
        if (key) {
            await context.secrets.store("openaiApiKey", key);
            vscode.window.showInformationMessage("‚úÖ OpenAI API key stored successfully.");
        }
    };
    functionRegister(setOpenAiKey);
    const clearOpenAiKey = async () => {
        await context.secrets.delete("openaiApiKey");
        vscode.window.showInformationMessage("üóëÔ∏è OpenAI API key successfully deleted.");
    };
    functionRegister(clearOpenAiKey);
    const setRepository = async () => (0, github_1.saveRepo)(context);
    functionRegister(setRepository);
    const clearRepository = async () => (0, github_1.deleteSavedRepo)(context);
    functionRegister(clearRepository);
    const showRepository = async () => {
        const cur = (0, github_1.getSavedRepoInfo)(context);
        vscode.window.showInformationMessage(`Current repository: ${cur ? cur.owner + "/" + cur.repo : "(none)"}`);
    };
    functionRegister(showRepository);
    const loginGithub = async () => {
        const before = await (0, github_1.getExistingGitHubSession)();
        const ok = await (0, github_1.getOctokitViaVSCodeAuth)();
        if (ok) {
            const after = await (0, github_1.getExistingGitHubSession)();
            const who = after?.account?.label ?? "GitHub";
            vscode.window.showInformationMessage(before ? `You are already logged in as ${who}` : `Successfully logged in as ${who}`);
        }
        else {
            vscode.window.showErrorMessage("GitHub login failed.");
        }
    };
    functionRegister(loginGithub);
    const logoutGithub = async () => {
        const session = await (0, github_1.getExistingGitHubSession)();
        if (!session) {
            vscode.window.showInformationMessage("You are not logged in.");
            return;
        }
        const isSignOut = await (0, github_1.isSignOutGitHub)();
        if (isSignOut) {
            vscode.window.showInformationMessage("GitHub logout successful.");
        }
    };
    functionRegister(logoutGithub);
    const analyzeGitHubActions = async (repoArg) => {
        console.log("[1] üîç ÌôïÏû• Ïã§ÌñâÎê®");
        // Ïö∞ÏÑ†ÏàúÏúÑ: Î™ÖÎ†π Ïù∏Ïûê > Ï†ÄÏû•Îêú Î†àÌè¨
        const repo = repoArg ?? (0, github_1.getSavedRepoInfo)(context);
        if (!repo) {
            vscode.window.showWarningMessage("No repository found. Please register one first.");
            return;
        }
        console.log(`[2] ‚úÖ Repository: ${repo.owner}/${repo.repo}`);
        const octokit = await (0, github_1.getOctokitViaVSCodeAuth)();
        if (!octokit) {
            vscode.window.showErrorMessage("GitHub login failed.");
            return;
        }
        console.log("[3] üîë VS Code GitHub ÏÑ∏ÏÖò ÌôïÎ≥¥");
        const run_id = await (0, getRunList_1.getRunIdFromQuickPick)(octokit, repo.owner, repo.repo);
        if (!run_id) {
            vscode.window.showInformationMessage("No workflow run selected.");
            return;
        }
        console.log(`[4] ‚úÖ Selected Run ID: ${run_id}`);
        const mode = await vscode.window.showQuickPick(["All logs", "Error messages only"], {
            placeHolder: "Select log scope to include in LLM prompt",
        });
        const logMode = mode === "All logs" ? "all" : "error";
        console.log(`[5] üìÑ Î°úÍ∑∏ Ï∂îÏ∂ú Î∞©Ïãù: ${logMode}`);
        await vscode.window.withProgress({
            location: vscode.ProgressLocation.Notification,
            title: `Analyzing Run #${run_id}...`,
        }, async (progress) => {
            try {
                progress.report({
                    message: "Downloading log ZIP and generating prompts",
                });
                const { failedSteps, prompts } = await (0, getFailedLogs_1.getFailedStepsAndPrompts)(octokit, repo.owner, repo.repo, run_id, logMode);
                (0, printToOutput_1.printToOutput)(`Run #${run_id} failed steps`, failedSteps);
                (0, printToOutput_1.printToOutput)(`Run #${run_id} ‚Üí LLM prompts`, prompts);
                if (prompts.length === 0) {
                    vscode.window.showInformationMessage("No logs available for analysis.");
                    return;
                }
                progress.report({ message: "Calling LLM" });
                const analysis = await (0, analyze_1.analyzePrompts)(context, prompts); // { summary, rootCause, suggestion }
                (0, printToOutput_1.printToOutput)("LLM analysis result", [JSON.stringify(analysis, null, 2)]);
                if (panels["dashboard"]) {
                    panels["dashboard"].webview.postMessage({
                        command: "llmAnalysisResult",
                        payload: analysis,
                    });
                    vscode.window.showInformationMessage("LLM analysis result has been displayed on the dashboard.");
                }
                else {
                    const summary = analysis.summary ?? "LLM analysis complete.";
                    const choice = await vscode.window.showInformationMessage(`üß† ${summary}`, "Open Output Panel", "Copy Summary");
                    if (choice === "Open Output Panel") {
                        vscode.commands.executeCommand("workbench.action.output.toggleOutput");
                    }
                    else if (choice === "Copy Summary") {
                        await vscode.env.clipboard.writeText(summary);
                        vscode.window.showInformationMessage("üìã Summary has been copied to clipboard.");
                    }
                }
            }
            catch (e) {
                vscode.window.showErrorMessage(`‚ùå Analysis failed: ${e?.message ?? e}`);
            }
        });
    };
    functionRegister(analyzeGitHubActions);
    const openDashboard = async () => {
        createAndShowWebview(context, "dashboard");
    };
    functionRegister(openDashboard);
    // Extension ÌôúÏÑ±Ìôî Ïãú ÏûêÎèôÏúºÎ°ú ÎåÄÏãúÎ≥¥Îìú Ïó¥Í∏∞
    setTimeout(() => {
        openDashboard();
    }, 100);
}
const panels = {};
const isNumeric = (s) => typeof s === "string" && /^\d+$/.test(s);
/**
 * Creates and shows a new webview panel, or reveals an existing one.
 * Manages panel lifecycle and communication between the extension and the webview.
 * @param context The extension context.
 * @param page The page to display in the webview ('dashboard', 'editor', 'history').
 */
function createAndShowWebview(context, page) {
    console.log(`[extension.ts] ÏõπÎ∑∞ ÏÉùÏÑ± ÏãúÏûë: ${page}`);
    const column = vscode.window.activeTextEditor
        ? vscode.window.activeTextEditor.viewColumn
        : undefined;
    const pageTitle = `MAD Ops: ${page.charAt(0).toUpperCase() + page.slice(1)}`;
    // If we already have a panel for this page, show it.
    if (panels[page]) {
        console.log(`[extension.ts] Í∏∞Ï°¥ Ìå®ÎÑê ÏÇ¨Ïö©: ${page}`);
        panels[page].reveal(column);
        // Also send a message to ensure the correct page is displayed, in case the user changed it.
        panels[page].webview.postMessage({ command: "changePage", page });
        return;
    }
    console.log(`[extension.ts] ÏÉà ÏõπÎ∑∞ Ìå®ÎÑê ÏÉùÏÑ±: ${pageTitle}`);
    const panel = vscode.window.createWebviewPanel(page, pageTitle, column || vscode.ViewColumn.One, {
        enableScripts: true,
        retainContextWhenHidden: true,
        localResourceRoots: [
            vscode.Uri.file(path.join(context.extensionPath, "out", "webview-build")),
        ],
    });
    console.log(`[extension.ts] ÏõπÎ∑∞ HTML ÏÑ§Ï†ï Ï§ë...`);
    panel.webview.html = getWebviewContent(context, panel);
    console.log(`[extension.ts] ÏõπÎ∑∞ HTML ÏÑ§Ï†ï ÏôÑÎ£å`);
    panel.webview.onDidReceiveMessage(async (message) => {
        // Settings Í¥ÄÎ†® Î©îÏãúÏßÄ Ï≤òÎ¶¨ (GitHub Ïù∏Ï¶ù Î∂àÌïÑÏöî)
        console.log('[extension.ts] Î∞õÏùÄ Î©îÏãúÏßÄ:', message.command, message);
        switch (message.command) {
            case 'checkSettings': {
                // Ï¥àÍ∏∞ ÏÑ§Ï†ï ÌôïÏù∏
                console.log('[extension.ts] ÏÑ§Ï†ï ÌôïÏù∏ Ï§ë...');
                const githubSession = await (0, github_1.getExistingGitHubSession)();
                const savedRepo = (0, github_1.getSavedRepoInfo)(context);
                const hasOpenAiKey = !!(await context.secrets.get("openaiApiKey"));
                console.log('[extension.ts] ÏÑ§Ï†ï ÏÉÅÌÉú:', {
                    hasGithubSession: !!githubSession,
                    hasSavedRepo: !!savedRepo,
                    hasOpenAiKey
                });
                const isConfigured = githubSession && savedRepo && hasOpenAiKey;
                // Ïã§Ï†ú ÏÑ§Ï†ï Îç∞Ïù¥ÌÑ∞Î•º Î™®Îã¨Ïóê Ï†ÑÎã¨
                console.log('[extension.ts] ÏÑ§Ï†ï Î™®Îã¨ ÌëúÏãú ÏöîÏ≤≠');
                // API ÌÇ§ Í∞ÄÏ†∏Ïò§Í∏∞ (Ïã§Ï†ú Í∞í Ï†ÑÎã¨)
                let apiKeyValue = '';
                if (hasOpenAiKey) {
                    const actualKey = await context.secrets.get("openaiApiKey");
                    if (actualKey) {
                        apiKeyValue = actualKey;
                    }
                }
                // GitHub ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ Í∞ÄÏ†∏Ïò§Í∏∞
                let githubUserInfo = null;
                if (githubSession) {
                    try {
                        const octokit = await (0, github_1.getOctokitViaVSCodeAuth)();
                        if (octokit) {
                            const { data: user } = await octokit.rest.users.getAuthenticated();
                            githubUserInfo = {
                                username: user.login,
                                avatarUrl: user.avatar_url,
                                name: user.name || user.login
                            };
                        }
                    }
                    catch (error) {
                        console.error('[extension.ts] GitHub ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ Í∞ÄÏ†∏Ïò§Í∏∞ Ïã§Ìå®:', error);
                        githubUserInfo = {
                            username: githubSession.account.label,
                            avatarUrl: '',
                            name: githubSession.account.label
                        };
                    }
                }
                const currentSettings = {
                    githubAuthenticated: !!githubSession,
                    githubUser: githubUserInfo,
                    openaiApiKey: apiKeyValue, // Ïã§Ï†ú API ÌÇ§ Ï†ÑÎã¨ (Îàà ÏïÑÏù¥ÏΩòÏúºÎ°ú Î≥¥Ïù¥Í∏∞/Ïà®Í∏∞Í∏∞ Í∞ÄÎä•)
                    repositoryUrl: savedRepo ? `${savedRepo.owner}/${savedRepo.repo}` : '',
                };
                console.log('[extension.ts] Ï†ÑÎã¨Ìï† ÏÑ§Ï†ï Îç∞Ïù¥ÌÑ∞:', currentSettings);
                // ÏÑ§Ï†ïÏù¥ ÏôÑÎ£åÎêòÏßÄ ÏïäÏïòÏùÑ ÎïåÎßå Î™®Îã¨ ÌëúÏãú
                if (!isConfigured) {
                    console.log('[extension.ts] ÏÑ§Ï†ïÏù¥ ÏôÑÎ£åÎêòÏßÄ ÏïäÏùå - Ï¥àÍ∏∞ ÏÑ§Ï†ï Î™®Îã¨ ÌëúÏãú');
                    panel.webview.postMessage({
                        command: "showSettings",
                        payload: {
                            isInitialSetup: true,
                            currentSettings: currentSettings
                        }
                    });
                }
                else {
                    console.log('[extension.ts] ÏÑ§Ï†ïÏù¥ Ïù¥ÎØ∏ ÏôÑÎ£åÎêòÏñ¥ ÏûàÏùå - Î™®Îã¨ ÌëúÏãúÌïòÏßÄ ÏïäÏùå');
                }
                return;
            }
            case 'openSettings': {
                // ÏÇ¨Ïö©ÏûêÍ∞Ä ÏàòÎèôÏúºÎ°ú ÏÑ§Ï†ï Î≤ÑÌäºÏùÑ ÌÅ¥Î¶≠ÌñàÏùÑ Îïå (Ìï≠ÏÉÅ Î™®Îã¨ ÌëúÏãú)
                console.log('[extension.ts] ÏàòÎèô ÏÑ§Ï†ï Ïó¥Í∏∞ ÏöîÏ≤≠');
                const githubSession = await (0, github_1.getExistingGitHubSession)();
                const savedRepo = (0, github_1.getSavedRepoInfo)(context);
                const hasOpenAiKey = !!(await context.secrets.get("openaiApiKey"));
                // API ÌÇ§ Í∞ÄÏ†∏Ïò§Í∏∞
                let apiKeyValue = '';
                if (hasOpenAiKey) {
                    const actualKey = await context.secrets.get("openaiApiKey");
                    if (actualKey) {
                        apiKeyValue = actualKey;
                    }
                }
                // GitHub ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ Í∞ÄÏ†∏Ïò§Í∏∞
                let githubUserInfo = null;
                if (githubSession) {
                    try {
                        const octokit = await (0, github_1.getOctokitViaVSCodeAuth)();
                        if (octokit) {
                            const { data: user } = await octokit.rest.users.getAuthenticated();
                            githubUserInfo = {
                                username: user.login,
                                avatarUrl: user.avatar_url,
                                name: user.name || user.login
                            };
                        }
                    }
                    catch (error) {
                        console.error('[extension.ts] GitHub ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ Í∞ÄÏ†∏Ïò§Í∏∞ Ïã§Ìå®:', error);
                        githubUserInfo = {
                            username: githubSession.account.label,
                            avatarUrl: '',
                            name: githubSession.account.label
                        };
                    }
                }
                const currentSettings = {
                    githubAuthenticated: !!githubSession,
                    githubUser: githubUserInfo,
                    openaiApiKey: apiKeyValue,
                    repositoryUrl: savedRepo ? `${savedRepo.owner}/${savedRepo.repo}` : '',
                };
                console.log('[extension.ts] ÏàòÎèô ÏÑ§Ï†ï Î™®Îã¨ ÌëúÏãú');
                panel.webview.postMessage({
                    command: "showSettings",
                    payload: {
                        isInitialSetup: false, // ÏàòÎèô Ïó¥Í∏∞Ïù¥ÎØÄÎ°ú Ï¥àÍ∏∞ ÏÑ§Ï†ïÏù¥ ÏïÑÎãò
                        currentSettings: currentSettings
                    }
                });
                return;
            }
            case 'requestGithubLogin': {
                // GitHub Î°úÍ∑∏Ïù∏ ÏöîÏ≤≠
                console.log('[extension.ts] GitHub Î°úÍ∑∏Ïù∏ ÏöîÏ≤≠ Î∞õÏùå');
                try {
                    const octokit = await (0, github_1.getOctokitViaVSCodeAuth)();
                    if (octokit) {
                        const session = await (0, github_1.getExistingGitHubSession)();
                        // GitHub APIÎ°ú ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ Í∞ÄÏ†∏Ïò§Í∏∞
                        try {
                            const { data: user } = await octokit.rest.users.getAuthenticated();
                            panel.webview.postMessage({
                                command: "githubLoginResult",
                                payload: {
                                    success: true,
                                    username: user.login,
                                    avatarUrl: user.avatar_url,
                                    name: user.name || user.login
                                }
                            });
                        }
                        catch (apiError) {
                            // API Ìò∏Ï∂ú Ïã§Ìå® Ïãú ÏÑ∏ÏÖò Ï†ïÎ≥¥Îßå ÏÇ¨Ïö©
                            panel.webview.postMessage({
                                command: "githubLoginResult",
                                payload: {
                                    success: true,
                                    username: session?.account?.label || 'GitHub User',
                                    avatarUrl: '',
                                    name: session?.account?.label || 'GitHub User'
                                }
                            });
                        }
                    }
                    else {
                        panel.webview.postMessage({
                            command: "githubLoginResult",
                            payload: {
                                success: false,
                                error: 'GitHub Î°úÍ∑∏Ïù∏Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.'
                            }
                        });
                    }
                }
                catch (error) {
                    panel.webview.postMessage({
                        command: "githubLoginResult",
                        payload: {
                            success: false,
                            error: error?.message || 'GitHub Î°úÍ∑∏Ïù∏ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.'
                        }
                    });
                }
                return;
            }
            case 'openExternalUrl': {
                // Ïô∏Î∂Ä URL Ïó¥Í∏∞
                const url = message.payload?.url;
                if (url) {
                    vscode.env.openExternal(vscode.Uri.parse(url));
                }
                return;
            }
            case 'saveSettings': {
                // ÏÑ§Ï†ï Ï†ÄÏû•
                console.log('[extension.ts] ÏÑ§Ï†ï Ï†ÄÏû• ÏöîÏ≤≠ Î∞õÏùå:', message.payload);
                try {
                    const { openaiApiKey, repositoryUrl } = message.payload;
                    // OpenAI API ÌÇ§ Ï†ÄÏû• (Ïã§Ï†ú Í∞íÏù¥ ÏûàÏùÑ ÎïåÎßå)
                    if (openaiApiKey && openaiApiKey.trim()) {
                        await context.secrets.store("openaiApiKey", openaiApiKey);
                    }
                    // Î†àÌè¨ÏßÄÌÜ†Î¶¨ Ï†ïÎ≥¥ Ï†ÄÏû•
                    if (repositoryUrl) {
                        const repoInfo = await Promise.resolve().then(() => __importStar(require('./github/repository/normalizeInputAsRepoInfo')));
                        const normalized = repoInfo.default(repositoryUrl);
                        if (normalized) {
                            const KEY = (await Promise.resolve().then(() => __importStar(require('./github/repository/Constants')))).KEY;
                            await context.globalState.update(KEY, `${normalized.owner}/${normalized.repo}`);
                        }
                    }
                    // Ï†ÄÏû• ÏôÑÎ£å Î©îÏãúÏßÄ
                    console.log('[extension.ts] ÏÑ§Ï†ï Ï†ÄÏû• ÏôÑÎ£å, ÏõπÎ∑∞Ïóê ÏïåÎ¶º');
                    console.log('[extension.ts] settingsSaved Î©îÏãúÏßÄ Ï†ÑÏÜ° Ï§ë...');
                    panel.webview.postMessage({
                        command: "settingsSaved",
                        payload: { success: true }
                    });
                    console.log('[extension.ts] settingsSaved Î©îÏãúÏßÄ Ï†ÑÏÜ° ÏôÑÎ£å');
                    vscode.window.showInformationMessage("‚úÖ Settings saved successfully.");
                }
                catch (error) {
                    panel.webview.postMessage({
                        command: "error",
                        payload: `Failed to save settings: ${error?.message || error}`
                    });
                    vscode.window.showErrorMessage(`Failed to save settings: ${error?.message || error}`);
                }
                return;
            }
        }
        // Í∏∞Ï°¥ Î©îÏãúÏßÄ Ï≤òÎ¶¨ (GitHub Ïù∏Ï¶ù ÌïÑÏöî)
        const octokit = await (0, github_1.getOctokitViaVSCodeAuth)();
        if (!octokit) {
            vscode.window.showErrorMessage("Failed to authenticate with GitHub.");
            return;
        }
        console.log("[3] üîë VS Code GitHub session acquired");
        const repo = (0, github_1.getSavedRepoInfo)(context);
        if (!repo) {
            panel.webview.postMessage({
                command: "error",
                payload: "Failed to find GitHub repository information.",
            });
            return;
        }
        switch (message.command) {
            case "getActions":
                try {
                    const { data: workflows } = await octokit.actions.listRepoWorkflows({
                        owner: repo.owner,
                        repo: repo.repo,
                    });
                    console.log(`[üìã] ÏõåÌÅ¨ÌîåÎ°úÏö∞ Í∞úÏàò: ${workflows.workflows.length}`);
                    if (workflows.workflows.length === 0) {
                        console.log("[‚ö†Ô∏è] ÏõåÌÅ¨ÌîåÎ°úÏö∞ ÌååÏùºÏù¥ ÏóÜÏäµÎãàÎã§.");
                        panel.webview.postMessage({
                            command: "getActionsResponse",
                            payload: [],
                        });
                        return;
                    }
                    const actions = (workflows.workflows ?? []).map((w) => {
                        const key = w.path || String(w.id);
                        return {
                            // ÌîÑÎ°†Ìä∏ÏóêÏÑú Í∏∞Ï°¥ ÌïÑÎìúÎ™Ö(actionId)ÏùÑ Í∑∏ÎåÄÎ°ú Ïì∞Îêò, Í∞íÏùÄ "Í≤ΩÎ°ú"Î°ú Î≥¥ÎÉÑ
                            actionId: key,
                            id: String(w.id), // Ï∞∏Í≥†Ïö©
                            path: w.path ?? null, // Ï∞∏Í≥†Ïö©
                            name: w.name ?? key,
                            status: w.state === "active" ? "success" : "failed",
                        };
                    });
                    console.log(`[‚úÖ] ÏõåÌÅ¨ÌîåÎ°úÏö∞ Î™©Î°ù:`, actions);
                    send(panel, "getActionsResponse", actions);
                }
                catch (error) {
                    console.error("Error fetching actions:", error);
                    send(panel, "error", "ÏõåÌÅ¨ÌîåÎ°úÏö∞ Î™©Î°ùÏùÑ Í∞ÄÏ†∏Ïò§ÎäîÎç∞ Ïã§Ìå®ÌñàÏäµÎãàÎã§.");
                }
                break;
            case "getLatestRun":
                try {
                    const actionId = message.payload?.actionId;
                    if (!actionId) {
                        send(panel, "error", "Action IDÍ∞Ä ÌïÑÏöîÌï©ÎãàÎã§.");
                        return;
                    }
                    const workflowIdOrPath = String(actionId);
                    const { data: runs } = await octokit.actions.listWorkflowRuns({
                        owner: repo.owner,
                        repo: repo.repo,
                        // GitHub APIÎäî Î¨∏ÏûêÏó¥ Í≤ΩÎ°ú('.github/workflows/ci.yml') ÎòêÎäî Ïà´Ïûê id Î™®Îëê ÌóàÏö©
                        workflow_id: isNumeric(workflowIdOrPath)
                            ? Number(workflowIdOrPath)
                            : workflowIdOrPath,
                        per_page: 1,
                    });
                    if (runs.workflow_runs.length > 0) {
                        const run = runs.workflow_runs[0];
                        const latestRun = {
                            id: run.id.toString(),
                            status: run.status,
                            conclusion: run.conclusion || "unknown",
                            timestamp: run.created_at,
                            reason: run.head_commit?.message || "Unknown",
                        };
                        send(panel, "getLatestRunResponse", latestRun);
                    }
                    else {
                        send(panel, "getLatestRunResponse", null);
                    }
                }
                catch (error) {
                    console.error("Error fetching latest run:", error);
                    send(panel, "error", "ÏµúÏã† Ïã§Ìñâ Ï†ïÎ≥¥Î•º Í∞ÄÏ†∏Ïò§ÎäîÎç∞ Ïã§Ìå®ÌñàÏäµÎãàÎã§.");
                }
                break;
            case "getRunHistory":
                try {
                    const actionId = message.payload?.actionId;
                    if (!actionId) {
                        send(panel, "error", "Action IDÍ∞Ä ÌïÑÏöîÌï©ÎãàÎã§.");
                        return;
                    }
                    const workflowIdOrPath = String(actionId);
                    console.log(`[üîç] ÏõåÌÅ¨ÌîåÎ°úÏö∞ ${workflowIdOrPath} Ïã§Ìñâ Í∏∞Î°ù Ï°∞Ìöå (owner=${repo.owner}, repo=${repo.repo})`);
                    const { data: runs } = await octokit.actions.listWorkflowRuns({
                        owner: repo.owner,
                        repo: repo.repo,
                        workflow_id: isNumeric(workflowIdOrPath)
                            ? Number(workflowIdOrPath)
                            : workflowIdOrPath,
                        per_page: 10,
                    });
                    console.log(`[üìä] Ïã§Ìñâ Í∏∞Î°ù Í∞úÏàò: ${runs.workflow_runs.length}`);
                    const runHistory = runs.workflow_runs.map((run) => ({
                        id: run.id.toString(),
                        status: run.status,
                        conclusion: run.conclusion || "unknown",
                        timestamp: run.created_at,
                        reason: run.head_commit?.message || "Unknown",
                        branch: run.head_branch,
                        commit: run.head_sha?.substring(0, 7) || "Unknown",
                        author: run.head_commit?.author?.name || "Unknown",
                    }));
                    send(panel, "getRunHistoryResponse", runHistory);
                }
                catch (error) {
                    console.error("Error fetching run history:", error);
                    send(panel, "error", "Ïã§Ìñâ Í∏∞Î°ùÏùÑ Í∞ÄÏ†∏Ïò§ÎäîÎç∞ Ïã§Ìå®ÌñàÏäµÎãàÎã§.");
                }
                break;
            case "getLatestRunFromAllActions":
                try {
                    console.log(`[üîç] Î™®Îì† actions Ï§ë Í∞ÄÏû• ÏµúÍ∑º run Ï°∞Ìöå (owner=${repo.owner}, repo=${repo.repo})`);
                    const { data: workflows } = await octokit.actions.listRepoWorkflows({
                        owner: repo.owner,
                        repo: repo.repo,
                    });
                    let latestRun = null;
                    let latestTimestamp = 0;
                    for (const workflow of workflows.workflows) {
                        try {
                            const { data: runs } = await octokit.actions.listWorkflowRuns({
                                owner: repo.owner,
                                repo: repo.repo,
                                workflow_id: workflow.id,
                                per_page: 1,
                            });
                            if (runs.workflow_runs.length > 0) {
                                const run = runs.workflow_runs[0];
                                const runTimestamp = new Date(run.created_at).getTime();
                                if (runTimestamp > latestTimestamp) {
                                    latestTimestamp = runTimestamp;
                                    latestRun = {
                                        id: run.id.toString(),
                                        status: run.status,
                                        conclusion: run.conclusion,
                                        timestamp: run.created_at,
                                        reason: run.head_commit?.message || "Unknown",
                                        actionId: workflow.path || workflow.id.toString(),
                                    };
                                }
                            }
                        }
                        catch (workflowError) {
                            console.log(`ÏõåÌÅ¨ÌîåÎ°úÏö∞ ${workflow.id} Ïã§Ìñâ Í∏∞Î°ù Ï°∞Ìöå Ïã§Ìå®:`, workflowError);
                        }
                    }
                    console.log(`[‚úÖ] Í∞ÄÏû• ÏµúÍ∑º run:`, latestRun);
                    send(panel, "getLatestRunFromAllActionsResponse", latestRun);
                }
                catch (error) {
                    console.error("Error fetching latest run from all actions:", error);
                    send(panel, "error", "Í∞ÄÏû• ÏµúÍ∑º Ïã§Ìñâ Ï†ïÎ≥¥Î•º Í∞ÄÏ†∏Ïò§ÎäîÎç∞ Ïã§Ìå®ÌñàÏäµÎãàÎã§.");
                }
                break;
            case "getRunDetails":
                try {
                    const runId = message.payload?.runId;
                    if (!runId) {
                        send(panel, "error", "Run IDÍ∞Ä ÌïÑÏöîÌï©ÎãàÎã§.");
                        return;
                    }
                    console.log(`[üîç] Run ÏÉÅÏÑ∏ Ï†ïÎ≥¥ Ï°∞Ìöå: ${runId} (owner=${repo.owner}, repo=${repo.repo})`);
                    const { data: run } = await octokit.actions.getWorkflowRun({
                        owner: repo.owner,
                        repo: repo.repo,
                        run_id: Number(runId),
                    });
                    const { data: jobs } = await octokit.actions.listJobsForWorkflowRun({
                        owner: repo.owner,
                        repo: repo.repo,
                        run_id: Number(runId),
                    });
                    const runDetails = {
                        id: run.id.toString(),
                        status: run.status,
                        conclusion: run.conclusion,
                        timestamp: run.created_at,
                        reason: run.head_commit?.message || "Unknown",
                        branch: run.head_branch || "Unknown",
                        workflow: run.name || "Unknown",
                        runNumber: run.run_number,
                        duration: "Unknown", // GitHub APIÏóêÏÑú durationÏùÑ ÏßÅÏ†ë Ï†úÍ≥µÌïòÏßÄ ÏïäÏùå
                        commit: run.head_sha?.substring(0, 7) || "Unknown",
                        author: run.head_commit?.author?.name || "Unknown",
                        jobs: jobs.jobs,
                    };
                    console.log(`[‚úÖ] Run ÏÉÅÏÑ∏ Ï†ïÎ≥¥:`, runDetails);
                    send(panel, "getRunDetailsResponse", runDetails);
                }
                catch (error) {
                    console.error("Error fetching run details:", error);
                    send(panel, "error", "Run ÏÉÅÏÑ∏ Ï†ïÎ≥¥Î•º Í∞ÄÏ†∏Ïò§ÎäîÎç∞ Ïã§Ìå®ÌñàÏäµÎãàÎã§.");
                }
                break;
            case "getRunLogs":
                try {
                    const runId = message.payload?.runId;
                    if (!runId) {
                        send(panel, "error", "Run IDÍ∞Ä ÌïÑÏöîÌï©ÎãàÎã§.");
                        return;
                    }
                    console.log(`[üîç] Run Î°úÍ∑∏ Îã§Ïö¥Î°úÎìú: ${runId} (owner=${repo.owner}, repo=${repo.repo})`);
                    const { data: logs } = await octokit.request("GET /repos/{owner}/{repo}/actions/runs/{run_id}/logs", {
                        owner: repo.owner,
                        repo: repo.repo,
                        run_id: Number(runId),
                        request: { responseType: "arraybuffer" },
                    });
                    const JSZip = require("jszip");
                    const zip = await JSZip.loadAsync(logs);
                    let allLogs = "";
                    const txtFiles = Object.values(zip.files).filter((f) => !f.dir && f.name.endsWith(".txt"));
                    for (const file of txtFiles) {
                        const content = await file.async("string");
                        allLogs += `=== ${file.name} ===\n${content}\n\n`;
                    }
                    console.log(`[‚úÖ] Run Î°úÍ∑∏ Îã§Ïö¥Î°úÎìú ÏôÑÎ£å: ${txtFiles.length}Í∞ú ÌååÏùº`);
                    send(panel, "getRunLogsResponse", allLogs);
                }
                catch (error) {
                    console.error("Error fetching run logs:", error);
                    // [FIX] Î°úÍ∑∏Î•º Í∞ÄÏ†∏Ïò¨ Ïàò ÏóÜÏùÑ Îïå ÏóêÎü¨ ÎåÄÏã† ÏïàÎÇ¥ Î©îÏãúÏßÄ Ï†ÑÏÜ°
                    const errorMsg = error?.status === 404
                        ? "Î°úÍ∑∏Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§. (Î°úÍ∑∏Í∞Ä ÎßåÎ£åÎêòÏóàÍ±∞ÎÇò, ÏïÑÏßÅ ÏÉùÏÑ±ÎêòÏßÄ ÏïäÏïòÍ±∞ÎÇò, ÏßÑÌñâ Ï§ëÏùº Ïàò ÏûàÏäµÎãàÎã§)"
                        : `Î°úÍ∑∏Î•º Í∞ÄÏ†∏Ïò§ÎäîÎç∞ Ïã§Ìå®ÌñàÏäµÎãàÎã§: ${error?.message || error}`;
                    send(panel, "getRunLogsResponse", errorMsg);
                }
                break;
            case "getWorkflowFile":
                async function getFileText(octokit, repo, filePath, ref = "main") {
                    const r = await octokit.repos.getContent({
                        owner: repo.owner,
                        repo: repo.repo,
                        path: filePath,
                        ref,
                    });
                    if (Array.isArray(r.data))
                        return "";
                    const base64 = r.data.content?.replace(/\n/g, "") ?? "";
                    return Buffer.from(base64, "base64").toString("utf8");
                }
                try {
                    const actionId = String(message.payload?.actionId);
                    if (!actionId) {
                        send(panel, "error", "Action IDÍ∞Ä ÌïÑÏöîÌï©ÎãàÎã§.");
                        return;
                    }
                    let workflowPath;
                    if (isNumericId(actionId)) {
                        const { data: wf } = await octokit.actions.getWorkflow({
                            owner: repo.owner,
                            repo: repo.repo,
                            workflow_id: Number(actionId),
                        });
                        workflowPath = ensureWorkflowPathFromWorkflow(wf);
                    }
                    else {
                        // Í≤ΩÎ°ú(.github/workflows/xxx.yml) Í∑∏ÎåÄÎ°ú ÏÇ¨Ïö© Í∞ÄÎä•
                        workflowPath = actionId;
                    }
                    const content = await getFileText(octokit, repo, workflowPath, "main");
                    send(panel, "getWorkflowFileResponse", content);
                }
                catch (error) {
                    console.error("Error fetching workflow file:", error);
                    const hint = error?.status === 404
                        ? " (Ïù¥ Î†àÌè¨Ïóê Ìï¥Îãπ ÏõåÌÅ¨ÌîåÎ°úÍ∞Ä ÏóÜÍ±∞ÎÇò Í∂åÌïú Î¨∏Ï†úÏùº Ïàò ÏûàÏäµÎãàÎã§.)"
                        : "";
                    send(panel, "error", "ÏõåÌÅ¨ÌîåÎ°úÏö∞ ÌååÏùºÏùÑ Í∞ÄÏ†∏Ïò§ÎäîÎç∞ Ïã§Ìå®ÌñàÏäµÎãàÎã§." + hint);
                }
                break;
            case "saveWorkflowFile": {
                async function getFileShaIfExists(octokit, repo, filePath, ref = "main") {
                    try {
                        const r = await octokit.repos.getContent({
                            owner: repo.owner,
                            repo: repo.repo,
                            path: filePath,
                            ref,
                        });
                        if (Array.isArray(r.data))
                            return undefined;
                        return r.data.sha;
                    }
                    catch (e) {
                        if (e?.status === 404)
                            return undefined;
                        throw e;
                    }
                }
                async function upsertFile(octokit, repo, filePath, contentUtf8, branch = "main", message) {
                    const sha = await getFileShaIfExists(octokit, repo, filePath, branch);
                    await octokit.repos.createOrUpdateFileContents({
                        owner: repo.owner,
                        repo: repo.repo,
                        path: filePath,
                        message: message ?? `chore(ci): update ${filePath}`,
                        content: Buffer.from(contentUtf8, "utf8").toString("base64"),
                        branch,
                        sha, // ÏûàÏúºÎ©¥ ÏóÖÎç∞Ïù¥Ìä∏, ÏóÜÏúºÎ©¥ ÏÉùÏÑ±
                        committer: { name: "MAD Bot", email: "mad@team-madops.local" },
                        author: { name: "MAD Bot", email: "mad@team-madops.local" },
                    });
                }
                try {
                    const actionId = String(message.payload?.actionId);
                    const content = String(message.payload?.content ?? "");
                    if (!actionId)
                        throw new Error("Action IDÍ∞Ä ÌïÑÏöîÌï©ÎãàÎã§.");
                    let workflowPath;
                    if (isNumericId(actionId)) {
                        const { data: wf } = await octokit.actions.getWorkflow({
                            owner: repo.owner,
                            repo: repo.repo,
                            workflow_id: Number(actionId),
                        });
                        workflowPath = ensureWorkflowPathFromWorkflow(wf);
                    }
                    else {
                        workflowPath = actionId; // Ïù¥ÎØ∏ Í≤ΩÎ°úÎ°ú ÎÑòÏñ¥Ïò¥ (.github/workflows/xxx.yml)
                    }
                    await upsertFile(octokit, repo, workflowPath, content, "main");
                    send(panel, "saveWorkflowFileResponse", {
                        ok: true,
                        path: workflowPath,
                    });
                }
                catch (error) {
                    // TODO: Î≥¥Ìò∏ Î∏åÎûúÏπòÎ©¥ Ïó¨Í∏∞ÏÑú feature Î∏åÎûúÏπò/PR Ìè¥Î∞± Ï∂îÍ∞Ä Í∞ÄÎä• : ?? Î®ºÏÜî
                    send(panel, "saveWorkflowFileResponse", {
                        ok: false,
                        error: error?.message ?? String(error),
                    });
                }
                break;
            }
            case "analyzeRun":
                try {
                    const runIdStr = message.payload?.runId;
                    if (typeof runIdStr !== "string") {
                        send(panel, "error", "Run IDÍ∞Ä Î¨∏ÏûêÏó¥Ïù¥ ÏïÑÎãôÎãàÎã§.");
                        return;
                    }
                    const runId = parseInt(runIdStr, 10);
                    if (isNaN(runId)) {
                        panel.webview.postMessage({
                            command: "error",
                            payload: `ÏûòÎ™ªÎêú Run ID ÌòïÏãùÏûÖÎãàÎã§: ${runIdStr}`,
                        });
                        return;
                    }
                    console.log(`[üöÄ] WebviewÎ°úÎ∂ÄÌÑ∞ LLM Î∂ÑÏÑù ÏöîÏ≤≠ ÏàòÏã† (Run ID: ${runId})`);
                    // [ADD] Run ÏÉÅÌÉú ÌôïÏù∏
                    const { data: run } = await octokit.actions.getWorkflowRun({
                        owner: repo.owner,
                        repo: repo.repo,
                        run_id: runId,
                    });
                    // [ADD] ÏÑ±Í≥µÌïú workflowÎäî LLM Î∂ÑÏÑù ÏóÜÏù¥ ÏÑ±Í≥µ Î©îÏãúÏßÄ Ï†ÑÏÜ°
                    if (run.conclusion === "success") {
                        console.log(`[‚úÖ] Run #${runId}Îäî ÏÑ±Í≥µÌïú ÏûëÏóÖÏûÖÎãàÎã§.`);
                        const successResult = {
                            runId,
                            status: "success",
                            summary: "ÏÑ±Í≥µÌïú ÏûëÏóÖÏûÖÎãàÎã§!",
                            rootCause: "",
                            suggestion: "",
                        };
                        if (panels["dashboard"]) {
                            panels["dashboard"].webview.postMessage({
                                command: "llmAnalysisResult",
                                payload: successResult,
                            });
                        }
                        else {
                            send(panel, "llmAnalysisResult", successResult);
                        }
                        return;
                    }
                    // TODO : Ïó¨Í∏∞ÏÑú triggerLlmAnalysis ÏÇ¨Ïö©, Ïù¥Î•º Ï†ÅÏ†àÌïòÍ≤å ÎåÄÏ≤¥ ÌïÑÏöî!
                    // await triggerLlmAnalysis(context, repo, runId);
                    // ‚úÖ Ïª§Îß®Îìú Í≤ΩÎ°úÏùò LLM Î∂ÑÏÑù Î∏îÎ°ùÏùÑ Í∑∏ÎåÄÎ°ú ÏÇ¨Ïö© (Î≥ÄÏàòÎ™ÖÎßå ÎßûÏ∂§)
                    const logMode = message.payload?.logMode === "all" ? "all" : "error";
                    await vscode.window.withProgress({
                        location: vscode.ProgressLocation.Notification,
                        title: `Analyzing Run #${runId} ...`,
                    }, async (progress) => {
                        try {
                            progress.report({
                                message: "Downloading log ZIP and generating prompts...",
                            });
                            const { failedSteps, prompts } = await (0, getFailedLogs_1.getFailedStepsAndPrompts)(octokit, repo.owner, repo.repo, runId, logMode);
                            (0, printToOutput_1.printToOutput)(`Run #${runId}  Failed steps`, failedSteps);
                            (0, printToOutput_1.printToOutput)(`Run #${runId} ‚Üí LLM prompts`, prompts);
                            if (prompts.length === 0) {
                                send(panel, "llmAnalysisResult", {
                                    runId,
                                    summary: "No logs available for analysis.",
                                    rootCause: null,
                                    suggestion: null,
                                    items: [],
                                });
                                vscode.window.showInformationMessage("No logs available for analysis.");
                                return;
                            }
                            progress.report({ message: "Calling LLM..." });
                            // const analysis = await analyzePrompts(prompts);
                            const analysis = await (0, analyze_1.analyzePrompts)(context, prompts);
                            (0, printToOutput_1.printToOutput)("LLM Î∂ÑÏÑù Í≤∞Í≥º", [
                                JSON.stringify(analysis, null, 2),
                            ]);
                            // [MOD] ÏÑ±Í≥µÏ†ÅÏúºÎ°ú Î∂ÑÏÑùÎêú Í≤∞Í≥ºÏóê status Ï∂îÍ∞Ä
                            const resultWithStatus = {
                                runId,
                                status: "failure",
                                ...analysis,
                            };
                            // Ïó¨Í∏∞ÏÑúÎäî ÌòÑÏû¨ Ïó¥Î†§ÏûàÎäî ÎåÄÏãúÎ≥¥ÎìúÎ°ú Î≥¥ÎÇ¥Í±∞ÎÇò, Î∞îÎ°ú Ïù¥ Ìå®ÎÑêÎ°ú ÌöåÏã† Îëò Ï§ë ÌÉù1
                            if (panels["dashboard"]) {
                                panels["dashboard"].webview.postMessage({
                                    command: "llmAnalysisResult",
                                    payload: resultWithStatus,
                                });
                            }
                            else {
                                send(panel, "llmAnalysisResult", resultWithStatus);
                            }
                        }
                        catch (e) {
                            const msg = e?.message ?? String(e);
                            console.error(`[‚ùå] LLM Î∂ÑÏÑù Ïã§Ìå®: ${msg}`);
                            // [MOD] ÏóêÎü¨ Ï†ïÎ≥¥Î•º UIÎ°ú Ï†ÑÏÜ°
                            const errorResult = {
                                runId,
                                status: "error",
                                summary: "Î∂ÑÏÑùÏù¥ Ïã§Ìå®ÌñàÏäµÎãàÎã§",
                                rootCause: "",
                                suggestion: "",
                                error: msg,
                            };
                            if (panels["dashboard"]) {
                                panels["dashboard"].webview.postMessage({
                                    command: "llmAnalysisResult",
                                    payload: errorResult,
                                });
                            }
                            else {
                                send(panel, "llmAnalysisResult", errorResult);
                            }
                            vscode.window.showErrorMessage(`‚ùå Analysis failed: ${msg}`);
                        }
                    });
                }
                catch (error) {
                    console.error("LLM analysis start error:", error);
                    send(panel, "error", "Failed to start LLM analysis.");
                }
                break;
            case "analyzeSecondPass":
                try {
                    const payload = message.payload || {};
                    const targetPath = String(payload.path || "");
                    if (!targetPath) {
                        send(panel, "error", "Second analysis: path is empty.");
                        break;
                    }
                    const lineHint = Number.isFinite(Number(payload.lineHint)) ? Number(payload.lineHint) : undefined;
                    const logExcerpt = String(payload.logExcerpt || "");
                    const contextMeta = (payload.context && typeof payload.context === "object") ? payload.context : undefined;
                    const radius = Number.isFinite(Number(payload.radius)) ? Number(payload.radius) : 30;
                    const ref = payload.ref ? String(payload.ref) : "main";
                    // ÏΩîÎìú Î≥∏Î¨∏ ÏùΩÍ∏∞
                    const fullText = await getRepoFileText(octokit, repo, targetPath, ref);
                    if (!fullText) {
                        send(panel, "error", `Unable to read file: ${targetPath} @ ${ref}`);
                        break;
                    }
                    const codeWindow = buildCodeWindow(fullText, lineHint, radius);
                    const input = {
                        path: targetPath,
                        logExcerpt,
                        codeWindow,
                        lineHint,
                        context: contextMeta,
                    };
                    // LLM 2Ï∞® Î∂ÑÏÑù
                    const result = await (0, secondPass_1.analyzeSecondPass)(context, input);
                    // Ï∂úÎ†•/Ï†ÑÎã¨
                    (0, printToOutput_1.printToOutput)("LLM 2nd Pass Analysis Result", [JSON.stringify(result, null, 2)]);
                    if (panels["dashboard"]) {
                        panels["dashboard"].webview.postMessage({
                            command: "secondPassResult",
                            payload: { ...result, file: targetPath },
                        });
                    }
                    else {
                        send(panel, "secondPassResult", { ...result, file: targetPath });
                    }
                }
                catch (error) {
                    console.error("2nd Pass analysis error:", error);
                    send(panel, "error", `2nd Pass analysis failed: ${error?.message || error}`);
                }
                break;
            case "analyzeLog":
                send(panel, "error", "Log analysis is not yet implemented.");
                break;
        }
    }, undefined, context.subscriptions);
    // Handle when the panel is closed
    panel.onDidDispose(() => {
        delete panels[page];
    }, null, context.subscriptions);
    // Store the panel and send the initial page message
    panels[page] = panel;
    panel.webview.postMessage({ command: "changePage", page });
}
function getWebviewContent(context, panel) {
    const buildPath = path.join(context.extensionPath, "out", "webview-build");
    const scriptPath = path.join(buildPath, "assets", "index.js");
    const stylePath = path.join(buildPath, "assets", "index.css");
    const scriptUri = panel.webview.asWebviewUri(vscode.Uri.file(scriptPath));
    const styleUri = panel.webview.asWebviewUri(vscode.Uri.file(stylePath));
    const nonce = getNonce();
    console.log('[extension.ts] ÏõπÎ∑∞ HTML ÏÉùÏÑ± Ï§ë...');
    console.log('[extension.ts] ÎπåÎìú Í≤ΩÎ°ú:', buildPath);
    console.log('[extension.ts] Ïä§ÌÅ¨Î¶ΩÌä∏ URI:', scriptUri.toString());
    console.log('[extension.ts] Ïä§ÌÉÄÏùº URI:', styleUri.toString());
    // The title here is for the HTML document itself, not the panel tab.
    const html = `<!DOCTYPE html>
    <html lang="en">
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta http-equiv="Content-Security-Policy" content="default-src 'none'; style-src ${panel.webview.cspSource} 'unsafe-inline'; script-src 'nonce-${nonce}'; font-src ${panel.webview.cspSource} data:; img-src ${panel.webview.cspSource} https: data:;">
      <title>MAD Ops</title>
      <link rel="stylesheet" type="text/css" href="${styleUri}">
    </head>
    <body>
      <div id="root"></div>
      <script nonce="${nonce}">
        // VSCode API Ï£ºÏûÖ (ÏôÑÏ†Ñ Í≤©Î¶¨)
        console.log('[Webview] Ïä§ÌÅ¨Î¶ΩÌä∏ Î°úÎìú ÏãúÏûë');
        
        // acquireVsCodeApi Ìï®ÏàòÎ•º ÏûÑÏãúÎ°ú Ï†ÄÏû•
        const originalAcquireVsCodeApi = window.acquireVsCodeApi;
        
        try {
          // Ìïú Î≤àÎßå Ï¥àÍ∏∞Ìôî
          if (!window.vscode) {
            window.vscode = originalAcquireVsCodeApi();
            console.log('[Webview] VSCode API Ï¥àÍ∏∞ÌôîÎê®');
            console.log('[Webview] vscode Í∞ùÏ≤¥:', window.vscode);
          } else {
            console.log('[Webview] VSCode API Ïù¥ÎØ∏ Ï°¥Ïû¨Ìï®');
          }
          
          // acquireVsCodeApi Ìï®ÏàòÎ•º Ï†úÍ±∞ÌïòÏó¨ Ï§ëÎ≥µ Ìò∏Ï∂ú Î∞©ÏßÄ
          delete window.acquireVsCodeApi;
          
          // React Ïï±ÏóêÏÑú ÏÇ¨Ïö©Ìï† Ïàò ÏûàÎèÑÎ°ù Ï†ÑÏó≠ Ìï®Ïàò Ï†úÍ≥µ
          window.getVscode = function() {
            return window.vscode;
          };
          
        } catch (error) {
          console.log('[Webview] VSCode API Ï¥àÍ∏∞Ìôî Ïã§Ìå®:', error.message);
          // Ïã§Ìå®Ìï¥ÎèÑ acquireVsCodeApi Ìï®ÏàòÎäî Ï†úÍ±∞
          delete window.acquireVsCodeApi;
        }
      </script>
      <script nonce="${nonce}" src="${scriptUri}"></script>
    </body>
    </html>`;
    console.log('[extension.ts] ÏõπÎ∑∞ HTML ÏÉùÏÑ± ÏôÑÎ£å');
    return html;
}
function getNonce() {
    let text = "";
    const possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    for (let i = 0; i < 32; i++) {
        text += possible.charAt(Math.floor(Math.random() * possible.length));
    }
    return text;
}
function send(panel, command, payload) {
    panel.webview.postMessage({ command, payload });
}
function isNumericId(s) {
    return /^\d+$/.test(s);
}
function ensureWorkflowPathFromWorkflow(wf) {
    if (!wf?.path)
        throw new Error("Unable to find the workflow path.");
    return wf.path;
}
// Î†àÌè¨ÏóêÏÑú ÌÖçÏä§Ìä∏ ÌååÏùº Í∞ÄÏ†∏Ïò§Í∏∞ (main Í∏∞Ï§Ä)
async function getRepoFileText(octokit, repo, filePath, ref = "main") {
    const r = await octokit.repos.getContent({
        owner: repo.owner,
        repo: repo.repo,
        path: filePath,
        ref,
    });
    if (Array.isArray(r.data))
        return "";
    const base64 = r.data.content?.replace(/\n/g, "") ?? "";
    return Buffer.from(base64, "base64").toString("utf8");
}
// ÎùºÏù∏ ÌûåÌä∏ Ï§ëÏã¨ ¬±radius Ï§Ñ ÏΩîÎìú ÏúàÎèÑÏö∞ ÎßåÎì§Í∏∞
function buildCodeWindow(fullText, lineHint, radius = 30) {
    const lines = fullText.split(/\r?\n/);
    if (!lineHint || lineHint < 1 || lineHint > lines.length) {
        // ÎùºÏù∏ ÌûåÌä∏ ÏóÜÏúºÎ©¥ ÏïûÏ™Ω ÏùºÎ∂ÄÎßå
        return lines.slice(0, Math.min(200, lines.length)).join("\n");
    }
    const idx = lineHint - 1;
    const start = Math.max(0, idx - radius);
    const end = Math.min(lines.length, idx + radius + 1);
    return lines.slice(start, end).join("\n");
}
